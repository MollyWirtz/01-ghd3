<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Fraunces&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v6.min.js"></script>

<svg id="vis"></svg>

<script>
  // Add an SVG
  var svg = d3.select('#vis')
  .attr('width', '100%')
  .attr('height', '100%')
  .style('background-color', 'black')


  // Settings
  var numPrimitives = 500
  var width = document.getElementById('vis').clientWidth
  var height = document.getElementById('vis').clientWidth


  // Data
  var squareData = []
  var circleData = []
  // var polygonData = [ [0, 325], [25, 325], [12.5, 300] ]
  // var polygonData = [ [0, height], [width, height], [width/2, 0] ]  
  var polygonData = [ [0, 500], [500, 500], [500/2, 0] ]  
  var polygonData2 = [ [width/4, height/2], [width*.75, height/2], [width/2, height] ]  

  var txtData = [{title: 'CS 4802 - BioVisualization', label: 'Click me!'}]


  // Helper functions
  var xscale = d3.scaleLinear()
  .domain([0, 100])
  .range([0, width])

  function populateWithPrimitives(primitiveData) {
    console.log("populating")
    for (var i = 0 ; i < numPrimitives ; i++) {
      primitiveData.push({x: Math.floor(Math.floor(Math.random() * 101)), y: Math.floor(Math.floor(Math.random() * 101))})
    }
  }

  function onClickMe() {
    d3.select('#centerCircle')
    .transition()
    .duration(2000)
    .attr('r', width)

    d3.select('#circleTxt')
    .transition()
    .duration(2000)
    .style('opacity', 0)
    console.log("why")
  }


  // Add Rectangles
  populateWithPrimitives(squareData)

  svg.selectAll('rect')
  .data(squareData)
  .enter()
  .append('rect')
  .attr('x', function(d) { return xscale(d.x) })
  .attr('y', function(d) { return xscale(d.y) })
  .attr('width', 20)
  .attr('height', 20)
  .attr('fill', '#6564A6')
  .on('mouseover', function() {
    d3.select(this).attr('fill', '#81F495')
  })

  
  // Add Circles
  populateWithPrimitives(circleData)

  svg.selectAll('circle')
  .data(circleData)
  .enter()
  .append('circle')
  .attr('cx', function(d) { return xscale(d.x) })
  .attr('cy', function(d) { return xscale(d.y) })
  .attr('r', 10)
  .attr('fill', '#30C0D9')
  .on('mouseover', function() {
    d3.select(this).attr('fill', 'orange')
  })


  var nodes = svg.selectAll("g")
    .data(['Click me!']);
  var g = nodes.enter().append("g")


  g.append("circle") 
  .attr("id", 'centerCircle')
  .attr('cx', '50%')
  .attr('cy', '50%')
  .attr('r', 100)
  .attr('fill', 'white')
  .on('click', function onClickMe() {
    d3.select('#centerCircle')
    .transition()
    .duration(2000)
    .attr('r', width)

    d3.select('#circleTxt')
    .transition()
    .duration(2000)
    .style('opacity', 0)

    var hull = d3.polygonHull(polygonData)
    var line = d3.line().curve(d3.curveLinearClosed)

    svg.append('path')
    .transition()
    .delay(2000)
    .duration(1000)
    .attr('id', 'outerTriangle')
    .attr('d', line(hull))
    .attr('fill', '#F3E43E')
    .attr('opacity', 1)

    sierpinskiTriangle(10, 500, 500, hull, line)

  })


  g.append('text')
  .text(function (d) {
    return d
  })
  .attr('id', 'circleTxt')
  .attr('text-anchor', 'middle')
  .attr('x', '50%')
  .attr('y', '50%')
  .style('font-size', 16)
  .style('fill', 'black')
  .style('font-family', 'Fraunces')
  .style('font-weight', 500)
  .on('click', function () {
    d3.select('#centerCircle')
    .transition()
    .duration(2000)
    .attr('r', width)

    d3.select('#circleTxt')
    .transition()
    .duration(2000)
    .style('opacity', 0)
  })
  
  
  // Add Lines
  // svg.append('line')
  // .attr('x1', 0)
  // .attr('y1', 250)
  // .attr('x2', 400)
  // .attr('y2', 250)
  // .style('stroke', '#81F495')
  // .style('stroke-width', 10)


  // Add Polygons

  
  // Text
  svg
  .append('text')
  .data(txtData)
  .text(function (d) {
    return d.title
  })
  .attr('text-anchor', 'middle')
  .attr('x', '50%')
  .attr('y', '10%')
  .style('font-size', 42)
  .style('fill', 'white')
  .style('font-family', 'Fraunces')
  .style('font-weight', 700)





  function sierpinskiTriangle(numIterations, width, height, hull, line) {
    var iteration = 0
    var maxHeight = height

    drawBottomLeftTriangles(width, height, maxHeight, iteration, numIterations)
    drawBottomRightTriangles(width, height, maxHeight, width, iteration, numIterations)
    drawTopTriangles(width, height, maxHeight, width, iteration, numIterations)

  }

  function drawBottomLeftTriangles (width, height, maxHeight, iteration, numIterations) {
    while (iteration < numIterations) {

      width = width/2
      height = (height / 2) + maxHeight/2
      if (iteration === 0) {
        height = 250
      }

      coordinates = calculateBottomLeftCoordinates(width, height, maxHeight, iteration) 

      var fill = 'blue'
      
      var hull = d3.polygonHull(coordinates)
      var line = d3.line().curve(d3.curveLinearClosed)

      if (iteration % 2) {
        fill = 'red'
      }

      svg.append('path')
      .transition()
      .delay(2000)
      .duration(1000)
      .attr('d', line(hull))
      .attr('fill', fill)
      .attr('opacity', 1)
      iteration++
    }
  }

  function calculateBottomLeftCoordinates(width, height, maxHeight, iteration) {
    // console.log( [ [width/2, height], [width*1.5, height], [width, maxHeight] ])
    return [ [width/2, height], [width*1.5, height], [width, maxHeight] ]
  }

  function drawBottomRightTriangles (width, height, maxHeight, maxWidth, iteration, numIterations) {
    while (iteration < numIterations) {

      // width = (width/2) + maxWidth/2
      width = (width/2) 
      height = (height / 2) + maxHeight/2
      if (iteration === 0) {
        height = 250
        // width = 250
      }

      coordinates = calculateBottomRightCoordinates(width, height, maxHeight, maxWidth, iteration) 

      var fill = 'green'
      
      var hull = d3.polygonHull(coordinates)
      var line = d3.line().curve(d3.curveLinearClosed)

      if (iteration % 2) {
        fill = 'gray'
      }

      svg.append('path')
      .transition()
      .delay(2000)
      .duration(1000)
      .attr('d', line(hull))
      .attr('fill', fill)
      .attr('opacity', 1)
      iteration++
    }
  }

  function calculateBottomRightCoordinates(width, height, maxHeight, maxWidth, iteration) {
    // console.log( [  [width*1.25, height], [width+250, maxHeight], [width*1.5, height] ])
    // console.log( [ [width/2, height], [width*1.5, height], [width, maxHeight] ])
    // return [ [width*0.75, height], [width, maxHeight], [width*1.25, height] ] // close
    return [ [(maxWidth/2)*1.25, height], [(maxWidth/2)*1.5, maxHeight], [(maxWidth/2)*1.75, height] ] // closer
  }

  function drawTopTriangles (width, height, maxHeight, maxWidth, iteration, numIterations) {
    while (iteration < numIterations) {

      width = width / iteration///2  //+ 250/(iteration+1) //+ maxWidth/4
      height = (height / 2) //+ maxHeight/2
      if (iteration === 0) {
       // height = 250
        width = 250
      }

      console.log("width = " + width)

      coordinates = calculateTopCoordinates(width, height, maxHeight, maxWidth, iteration) 

      var fill = 'orange'
      
      var hull = d3.polygonHull(coordinates)
      var line = d3.line().curve(d3.curveLinearClosed)

      if (iteration % 2) {
        fill = 'black'
      }

      svg.append('path')
      .transition()
      .delay(2000)
      .duration(1000)
      .attr('d', line(hull))
      .attr('fill', fill)
      .attr('opacity', 1)
      iteration++
    }
  }

  function calculateTopCoordinates(width, height, maxHeight, maxWidth, iteration) {
    console.log( [  [width*0.75, height/2], [width, height], [width*1.25, height/2]])
    // console.log( [ [width/2, height], [width*1.5, height], [width, maxHeight] ])
    // return [ [width*0.75, height], [width, maxHeight], [width*1.25, height] ] // close
    return [ [width*0.75, height/2], [width, height], [width*1.25, height/2] ] 
                                        // good
  }


</script>

<body style="margin: 0;"></body>
